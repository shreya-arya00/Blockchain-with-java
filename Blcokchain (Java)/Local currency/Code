import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

class Transaction {
    String sender;
    String receiver;
    int amount;
    String signature;

    Transaction(String sender, String receiver, int amount, String signature) {
        this.sender = sender;
        this.receiver = receiver;
        this.amount = amount;
        this.signature = signature;
    }

    @Override
    public String toString() {
        return sender + " sent " + amount + " VC to " + receiver;
    }
}

class CoinBlock extends Block {
    List<Transaction> transactions;
    private int uniqueIdentifier;
    private KeyPair keyPair;

    CoinBlock(int id, int magicNumber, String previousHash, int N, KeyPair keyPair) {
        super(id, magicNumber, previousHash, N);
        this.transactions = new ArrayList<>();
        this.keyPair = keyPair;
        this.uniqueIdentifier = 0;
    }

    void addTransaction(String sender, String receiver, int amount) {
        String transactionContent = sender + receiver + amount;
        String signature = signMessage(transactionContent, keyPair.getPrivate());
        Transaction transaction = new Transaction(sender, receiver, amount, signature);
        transactions.add(transaction);
    }

    private String signMessage(String message, PrivateKey privateKey) {
        try {
            Signature privateSignature = Signature.getInstance("SHA256withRSA");
            privateSignature.initSign(privateKey);
            privateSignature.update(message.getBytes());
            byte[] signature = privateSignature.sign();
            return Base64.getEncoder().encodeToString(signature);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    boolean isValid() {
        if (!super.isValid()) {
            return false;
        }

        int maxId = 0;

        for (Transaction transaction : transactions) {
            if (transaction.amount <= 0 || transaction.id <= maxId || !verifySignature(transaction.sender + transaction.receiver + transaction.amount, transaction.signature, getPublicKeyFromString(transaction.sender))) {
                return false;
            }

            maxId = transaction.id;
        }

        return true;
    }

    private PublicKey getPublicKeyFromString(String publicKey) {
        try {
            byte[] keyBytes = Base64.getDecoder().decode(publicKey);
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            return keyFactory.generatePublic(keySpec);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    int getBalance(String person) {
        int balance = 100; // Initial virtual coins for everyone

        for (Transaction transaction : transactions) {
            if (transaction.receiver.equals(person)) {
                balance += transaction.amount;
            }

            if (transaction.sender.equals(person)) {
                balance -= transaction.amount;
            }
        }

        return balance;
    }

    @Override
    public String toString() {
        StringBuilder blockInfo = new StringBuilder(super.toString());
        if (transactions.isEmpty()) {
            blockInfo.append("No transactions\n");
        } else {
            blockInfo.append("Block data:\n");
            for (Transaction transaction : transactions) {
                blockInfo.append(transaction.toString()).append("\n");
            }
        }
        return blockInfo.toString();
    }
}

class Blockchain {
    List<Block> blocks;

    Blockchain() {
        blocks = new ArrayList<>();
        // Genesis block
        KeyPair keyPair = generateKeyPair();
        blocks.add(new CoinBlock(0, 0, "0", 0, keyPair));
    }

    void addTransaction(String sender, String receiver, int amount) {
        CoinBlock currentBlock = (CoinBlock) blocks.get(blocks.size() - 1);
        currentBlock.addTransaction(sender, receiver, amount);
    }

    private KeyPair generateKeyPair() {
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            return keyPairGenerator.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }

    private int getNextId() {
        return blocks.get(blocks.size() - 1).id + 1;
    }

    void addBlock(int minerId, int N) {
        KeyPair keyPair = generateKeyPair();
        CoinBlock previousBlock = (CoinBlock) blocks.get(blocks.size() - 1);
        CoinBlock newBlock = new CoinBlock(getNextId(), getRandomMagicNumber(), previousBlock.hash, N, keyPair);
        newBlock.transactions.addAll(previousBlock.transactions);
        newBlock.addTransaction("miner" + minerId, "miner" + minerId, 100); // Award 100 VC to the miner
        blocks.add(newBlock);
        System.out.println(newBlock);

        if (blocks.size() < 15) {
            System.out.println();
        }
    }

    int getBalance(String person) {
        int balance = 100; // Initial virtual coins for everyone

        for (Block block : blocks) {
            CoinBlock coinBlock = (CoinBlock) block;
            balance = coinBlock.getBalance(person);
        }

        return balance;
    }
}

public class LocalCurrencyBlockchain {
    public static void main(String[] args) {
        Blockchain blockchain = new Blockchain();
        List<Thread> minerThreads = new ArrayList<>();

        // Create and start 10 miner threads
        for (int i = 0; i < 10; i++) {
            Miner miner = new Miner(i + 1, blockchain);
            Thread minerThread = new Thread(miner);
            minerThreads.add(minerThread);
            minerThread.start();
        }

        // Simulate transactions
        blockchain.addTransaction("miner1", "miner2", 30);
        blockchain.addTransaction("miner1", "miner3", 30);
        blockchain.addTransaction("miner2", "miner3", 20);
        blockchain.addTransaction("miner4", "miner1", 15);
        blockchain.addTransaction("miner3", "miner4", 10);

        // Wait for all miner threads to finish
        for (Thread minerThread : minerThreads) {
            try {
                minerThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Print balances for each miner
        for (int i = 1; i <= 10; i++) {
            System.out.println("miner" + i + " has " + blockchain.getBalance("miner" + i) + " VC");
        }
    }
}
